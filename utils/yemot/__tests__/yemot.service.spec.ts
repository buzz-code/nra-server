// Generated by CodiumAI

import { YemotParams } from "@shared/entities/YemotCall.entity";
import { YemotService } from "../yemot.service";
import yemotUtil from "../yemot.util";

describe('YemotService', () => {
    let mockRepo: any;
    let mockUserRepo: any;
    let mockDataSource: any;
    let mockYemotChain: any;
    let body: YemotParams;

    beforeEach(() => {
        mockRepo = {
            findOne: jest.fn().mockResolvedValue({
                isOpen: true,
                history: [],
                data: body,
                currentStep: 'placeholder',
            }),
            create: jest.fn().mockResolvedValue({}),
            save: jest.fn().mockResolvedValue({}),
        };
        mockUserRepo = {
            findOneBy: jest.fn().mockResolvedValue({}),
        };
        mockDataSource = {};
        mockYemotChain = {
            handleRequest: jest.fn().mockImplementation((req, res, next) => next()),
        };
        body = {
            ApiCallId: "754b9ce7c434ea952f2ed99671c274fee143165a",
            ApiYFCallId: "9da82d44-c071-4c61-877b-1680d75968e6",
            ApiDID: "035586526",
            ApiRealDID: "035586526",
            ApiPhone: "0527609942",
            ApiExtension: "",
            ApiTime: "1669485562",
            reportDateType: "2",
            reportDate: "10112022",
            reportDateConfirm: "1",
            questionAnswer: "1",
            howManyLessons: "2",
            howManyWatchOrIndividual: "1",
            howManyTeachedOrInterfering: "0",
            wasKamal: "0",
            howManyDiscussingLessons: "1",
        } as any as YemotParams;
    });

    // handle a call with valid body
    it('should handle a call with valid body', async () => {
        // Mock dependencies

        const mockRepo = {
            findOne: jest.fn().mockResolvedValue(null),
            create: jest.fn().mockReturnValue({}),
            save: jest.fn().mockResolvedValue({}),
        } as any;

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Define test data

        // Invoke the method under test
        await yemotService.handleCall(body);

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).toHaveBeenCalledWith({
            user: expect.any(Object),
            apiCallId: body.ApiCallId,
            phone: body.ApiPhone,
            isOpen: true,
            history: [],
            data: body,
            currentStep: 'placeholder',
        });
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).toHaveBeenCalled();
    });

    // handle a call with existing active call
    it('should handle a call with existing active call', async () => {
        // Mock dependencies
        const mockRepo = {
            findOne: jest.fn().mockResolvedValue({}),
            create: jest.fn().mockReturnValue({}),
            save: jest.fn().mockResolvedValue({}),
        } as any;

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Define test data

        // Invoke the method under test
        await yemotService.handleCall(body);

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).not.toHaveBeenCalled();
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).toHaveBeenCalled();
    });

    // should handle a call with a hangup signal
    it('should handle a call with a hangup signal', async () => {
        // Mock dependencies

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Define test data

        // Invoke the method under test
        await yemotService.handleCall({ ...body, hangup: 'true' });

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).not.toHaveBeenCalled();
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).not.toHaveBeenCalled();
    });

    // should handle call with duplicate values
    it('should handle call with duplicate values', async () => {
        // Mock dependencies
        mockRepo = {
            findOne: jest.fn().mockResolvedValue(null),
            create: jest.fn().mockReturnValue({}),
            save: jest.fn().mockResolvedValue({}),
        } as any;

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Define test data
        body = {
            ApiCallId: "754b9ce7c434ea952f2ed99671c274fee143165a",
            ApiYFCallId: "9da82d44-c071-4c61-877b-1680d75968e6",
            ApiDID: "035586526",
            ApiRealDID: "035586526",
            ApiPhone: "0527609942",
            ApiExtension: "",
            ApiTime: "1669485562",
            reportDateType: ["2", "1"],
            reportDate: "10112022",
            reportDateConfirm: "1",
            questionAnswer: "1",
            howManyLessons: "2",
            howManyWatchOrIndividual: "1",
            howManyTeachedOrInterfering: "0",
            wasKamal: "0",
            howManyDiscussingLessons: "1",
        } as any as YemotParams;

        // Invoke the method under test
        await yemotService.handleCall(body);

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).toHaveBeenCalledWith({
            user: expect.any(Object),
            apiCallId: body.ApiCallId,
            phone: body.ApiPhone,
            isOpen: true,
            history: [],
            data: body,
            currentStep: 'placeholder',
        });
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).toHaveBeenCalled();
    });

    // should handle call with empty body
    it('should handle call with empty body', async () => {
        // Mock dependencies
        mockRepo = {
            findOne: jest.fn().mockResolvedValue(null),
            create: jest.fn().mockReturnValue({}),
            save: jest.fn().mockResolvedValue({}),
        } as any;

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Define test data

        // Invoke the method under test
        await expect(yemotService.handleCall({} as YemotParams)).resolves.toEqual(yemotUtil.send(
            yemotUtil.id_list_message_v2('שגיאה'),
            yemotUtil.hangup(),
        ));
    });

    // handle a call with valid body and no active call
    it('should handle a call with valid body and no active call', async () => {
        // Mock dependencies
        mockRepo.findOne.mockResolvedValue(null);
        mockRepo.create.mockReturnValue({});
        mockRepo.save.mockResolvedValue({});

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Invoke the method under test
        await yemotService.handleCall(body);

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).toHaveBeenCalledWith({
            user: expect.any(Object),
            apiCallId: body.ApiCallId,
            phone: body.ApiPhone,
            isOpen: true,
            history: [],
            data: body,
            currentStep: 'placeholder',
        });
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).toHaveBeenCalled();
    });

    // handle a call with existing active call
    it('should handle a call with existing active call', async () => {
        // Mock dependencies
        mockRepo.findOne.mockResolvedValue({});
        mockRepo.create.mockReturnValue({});
        mockRepo.save.mockResolvedValue({});

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Invoke the method under test
        await yemotService.handleCall(body);

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).not.toHaveBeenCalled();
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).toHaveBeenCalled();
    });

    // handle a call with a hangup signal
    it('should handle a call with a hangup signal', async () => {
        // Mock dependencies
        mockRepo.findOne.mockResolvedValue({
            isOpen: true,
            history: [],
            data: body,
            currentStep: 'placeholder',
        });

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Invoke the method under test
        await yemotService.handleCall({ ...body, hangup: 'true' });

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: body.ApiCallId,
            },
        });
        expect(mockRepo.create).not.toHaveBeenCalled();
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).not.toHaveBeenCalled();
    });

    // handle call with duplicate values
    it('should handle call with duplicate values', async () => {
        // Mock dependencies
        mockRepo.findOne.mockResolvedValue(null);
        mockRepo.create.mockReturnValue({});
        mockRepo.save.mockResolvedValue({});

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Define test data with duplicate values
        const duplicateBody = {
            ...body,
            reportDateType: ["2", "1"] as any,
        };

        // Invoke the method under test
        await yemotService.handleCall(duplicateBody);

        // Assertions
        expect(mockRepo.findOne).toHaveBeenCalledWith({
            where: {
                apiCallId: duplicateBody.ApiCallId,
            },
        });
        expect(mockRepo.create).toHaveBeenCalledWith({
            user: expect.any(Object),
            apiCallId: duplicateBody.ApiCallId,
            phone: duplicateBody.ApiPhone,
            isOpen: true,
            history: [],
            data: duplicateBody,
            currentStep: 'placeholder',
        });
        expect(mockRepo.save).toHaveBeenCalledWith(expect.any(Object));
        expect(mockYemotChain.handleRequest).toHaveBeenCalled();
    });

    // handle call with empty body
    it('should handle call with empty body', async () => {
        // Mock dependencies
        mockRepo.findOne.mockResolvedValue(null);
        mockRepo.create.mockReturnValue({});
        mockRepo.save.mockResolvedValue({});

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Invoke the method under test
        await expect(yemotService.handleCall({} as YemotParams)).resolves.toEqual(yemotUtil.send(
            yemotUtil.id_list_message_v2('שגיאה'),
            yemotUtil.hangup(),
        ));
    });

    // handle call when user is not found
    it('should handle call when user is not found', async () => {
        // Mock dependencies
        mockRepo.findOne.mockResolvedValue(null);
        mockUserRepo.findOneBy.mockResolvedValue(null);

        // Create instance of YemotService with mocked dependencies
        const yemotService = new YemotService(
            mockRepo,
            mockUserRepo,
            mockDataSource,
            mockYemotChain
        );

        // Invoke the method under test
        await expect(yemotService.handleCall(body)).resolves.toEqual(yemotUtil.send(
            yemotUtil.id_list_message_v2('מספר הטלפון עדיין לא חובר למשתמש באתר יומנט'),
            yemotUtil.hangup(),
        ));
    });
});
